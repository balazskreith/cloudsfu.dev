<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=cGvuclDC_Z1vE_cnVEU6AZsO3ysCNeUrywZHr_1BvaGU4zt5n9kJEydfdvJsjdvC);.lst-kix_nqwuhbphjnan-3>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-2>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-4>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-1>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-5>li:before{content:"-  "}ul.lst-kix_4pl8at941oz5-0{list-style-type:none}ul.lst-kix_4pl8at941oz5-1{list-style-type:none}ul.lst-kix_7pn7md83e75l-3{list-style-type:none}ul.lst-kix_7pn7md83e75l-2{list-style-type:none}ul.lst-kix_7pn7md83e75l-1{list-style-type:none}ul.lst-kix_7pn7md83e75l-0{list-style-type:none}ul.lst-kix_4pl8at941oz5-2{list-style-type:none}ul.lst-kix_4pl8at941oz5-3{list-style-type:none}.lst-kix_nqwuhbphjnan-0>li:before{content:"-  "}ul.lst-kix_4pl8at941oz5-4{list-style-type:none}ul.lst-kix_4pl8at941oz5-5{list-style-type:none}ul.lst-kix_4pl8at941oz5-6{list-style-type:none}ul.lst-kix_4pl8at941oz5-7{list-style-type:none}ul.lst-kix_4pl8at941oz5-8{list-style-type:none}ul.lst-kix_7pn7md83e75l-7{list-style-type:none}ul.lst-kix_7pn7md83e75l-6{list-style-type:none}ul.lst-kix_7pn7md83e75l-5{list-style-type:none}ul.lst-kix_7pn7md83e75l-4{list-style-type:none}ul.lst-kix_7pn7md83e75l-8{list-style-type:none}ul.lst-kix_mfmujm51lw8f-8{list-style-type:none}ul.lst-kix_mfmujm51lw8f-3{list-style-type:none}ul.lst-kix_mfmujm51lw8f-2{list-style-type:none}ul.lst-kix_mfmujm51lw8f-1{list-style-type:none}ul.lst-kix_mfmujm51lw8f-0{list-style-type:none}ul.lst-kix_nqwuhbphjnan-7{list-style-type:none}ul.lst-kix_mfmujm51lw8f-7{list-style-type:none}ul.lst-kix_nqwuhbphjnan-8{list-style-type:none}ul.lst-kix_mfmujm51lw8f-6{list-style-type:none}ul.lst-kix_nqwuhbphjnan-5{list-style-type:none}ul.lst-kix_mfmujm51lw8f-5{list-style-type:none}ul.lst-kix_nqwuhbphjnan-6{list-style-type:none}ul.lst-kix_mfmujm51lw8f-4{list-style-type:none}ul.lst-kix_nqwuhbphjnan-3{list-style-type:none}.lst-kix_v64lmx6sv1qi-8>li:before{content:"-  "}ul.lst-kix_nqwuhbphjnan-4{list-style-type:none}ul.lst-kix_nqwuhbphjnan-1{list-style-type:none}.lst-kix_v64lmx6sv1qi-7>li:before{content:"-  "}ul.lst-kix_nqwuhbphjnan-2{list-style-type:none}ul.lst-kix_nqwuhbphjnan-0{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-6{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-7{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-8{list-style-type:none}.lst-kix_v64lmx6sv1qi-0>li:before{content:"-  "}ul.lst-kix_v64lmx6sv1qi-0{list-style-type:none}.lst-kix_v64lmx6sv1qi-1>li:before{content:"-  "}ul.lst-kix_v64lmx6sv1qi-1{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-2{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-3{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-4{list-style-type:none}ul.lst-kix_v64lmx6sv1qi-5{list-style-type:none}.lst-kix_v64lmx6sv1qi-4>li:before{content:"-  "}.lst-kix_v64lmx6sv1qi-3>li:before{content:"-  "}.lst-kix_v64lmx6sv1qi-5>li:before{content:"-  "}.lst-kix_v64lmx6sv1qi-2>li:before{content:"-  "}.lst-kix_v64lmx6sv1qi-6>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-7>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-6>li:before{content:"-  "}.lst-kix_nqwuhbphjnan-8>li:before{content:"-  "}.lst-kix_mfmujm51lw8f-0>li:before{content:"\0025cf   "}.lst-kix_4pl8at941oz5-1>li:before{content:"\0025cb   "}.lst-kix_4pl8at941oz5-2>li:before{content:"\0025a0   "}.lst-kix_4pl8at941oz5-3>li:before{content:"\0025cf   "}.lst-kix_7pn7md83e75l-0>li:before{content:"-  "}.lst-kix_7pn7md83e75l-1>li:before{content:"-  "}.lst-kix_mfmujm51lw8f-5>li:before{content:"\0025a0   "}.lst-kix_mfmujm51lw8f-4>li:before{content:"\0025cb   "}.lst-kix_4pl8at941oz5-4>li:before{content:"\0025cb   "}.lst-kix_mfmujm51lw8f-2>li:before{content:"\0025a0   "}.lst-kix_4pl8at941oz5-7>li:before{content:"\0025cb   "}.lst-kix_mfmujm51lw8f-1>li:before{content:"\0025cb   "}.lst-kix_mfmujm51lw8f-3>li:before{content:"\0025cf   "}.lst-kix_4pl8at941oz5-5>li:before{content:"\0025a0   "}.lst-kix_4pl8at941oz5-6>li:before{content:"\0025cf   "}.lst-kix_mfmujm51lw8f-6>li:before{content:"\0025cf   "}.lst-kix_hoaeav58y277-6>li:before{content:"-  "}.lst-kix_mfmujm51lw8f-7>li:before{content:"\0025cb   "}.lst-kix_4pl8at941oz5-0>li:before{content:"\0025cf   "}.lst-kix_hoaeav58y277-7>li:before{content:"-  "}.lst-kix_mfmujm51lw8f-8>li:before{content:"\0025a0   "}.lst-kix_hoaeav58y277-8>li:before{content:"-  "}ul.lst-kix_hoaeav58y277-8{list-style-type:none}ul.lst-kix_hoaeav58y277-7{list-style-type:none}ul.lst-kix_hoaeav58y277-6{list-style-type:none}ul.lst-kix_hoaeav58y277-5{list-style-type:none}.lst-kix_hoaeav58y277-4>li:before{content:"-  "}.lst-kix_hoaeav58y277-5>li:before{content:"-  "}.lst-kix_wqq2psdvbpvp-3>li:before{content:"-  "}.lst-kix_wqq2psdvbpvp-2>li:before{content:"-  "}.lst-kix_wqq2psdvbpvp-4>li:before{content:"-  "}.lst-kix_hoaeav58y277-3>li:before{content:"-  "}.lst-kix_hoaeav58y277-2>li:before{content:"-  "}.lst-kix_wqq2psdvbpvp-0>li:before{content:"-  "}.lst-kix_wqq2psdvbpvp-1>li:before{content:"-  "}.lst-kix_hoaeav58y277-0>li:before{content:"-  "}.lst-kix_hoaeav58y277-1>li:before{content:"-  "}.lst-kix_7pn7md83e75l-8>li:before{content:"-  "}ul.lst-kix_wqq2psdvbpvp-0{list-style-type:none}.lst-kix_4pl8at941oz5-8>li:before{content:"\0025a0   "}.lst-kix_7pn7md83e75l-7>li:before{content:"-  "}ul.lst-kix_wqq2psdvbpvp-5{list-style-type:none}.lst-kix_wqq2psdvbpvp-7>li:before{content:"-  "}ul.lst-kix_wqq2psdvbpvp-6{list-style-type:none}.lst-kix_wqq2psdvbpvp-6>li:before{content:"-  "}ul.lst-kix_wqq2psdvbpvp-7{list-style-type:none}ul.lst-kix_wqq2psdvbpvp-8{list-style-type:none}ul.lst-kix_wqq2psdvbpvp-1{list-style-type:none}.lst-kix_wqq2psdvbpvp-5>li:before{content:"-  "}ul.lst-kix_wqq2psdvbpvp-2{list-style-type:none}.lst-kix_7pn7md83e75l-2>li:before{content:"-  "}ul.lst-kix_wqq2psdvbpvp-3{list-style-type:none}ul.lst-kix_wqq2psdvbpvp-4{list-style-type:none}.lst-kix_7pn7md83e75l-3>li:before{content:"-  "}ul.lst-kix_hoaeav58y277-0{list-style-type:none}.lst-kix_7pn7md83e75l-4>li:before{content:"-  "}.lst-kix_7pn7md83e75l-5>li:before{content:"-  "}.lst-kix_wqq2psdvbpvp-8>li:before{content:"-  "}.lst-kix_7pn7md83e75l-6>li:before{content:"-  "}ul.lst-kix_hoaeav58y277-4{list-style-type:none}ul.lst-kix_hoaeav58y277-3{list-style-type:none}ul.lst-kix_hoaeav58y277-2{list-style-type:none}ul.lst-kix_hoaeav58y277-1{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c12{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#f8f8f8;border-left-style:solid;border-bottom-width:1pt;width:341.2pt;border-top-color:#000000;border-bottom-style:solid}.c22{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#f8f8f8;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c6{background-color:#f8f8f8;color:#333333;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Consolas";font-style:normal}.c11{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c38{color:#0000ff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c37{color:#0000ff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c5{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c29{color:#38761d;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c13{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:justify}.c15{background-color:#f8f8f8;font-size:10pt;font-family:"Consolas";color:#dd1144;font-weight:400}.c32{background-color:#f8f8f8;font-family:"Consolas";font-style:italic;color:#999988;font-weight:400}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c26{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c35{padding-top:0pt;padding-bottom:0pt;line-height:1.45;text-align:center}.c36{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c24{background-color:#f8f8f8;font-family:"Consolas";color:#008080;font-weight:400}.c8{border-spacing:0;border-collapse:collapse;margin-right:auto}.c20{background-color:#f8f8f8;font-family:"Consolas";color:#333333;font-weight:400}.c25{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c33{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c17{background-color:#f8f8f8;font-family:"Consolas";color:#dd1144;font-weight:400}.c34{background-color:#f8f8f8;font-family:"Consolas";color:#999999}.c3{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c30{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c7{background-color:#ffffff;font-size:10pt}.c19{orphans:2;widows:2}.c31{font-weight:400;font-family:"Roboto Mono"}.c16{color:inherit;text-decoration:inherit}.c28{page-break-after:avoid}.c23{font-size:10pt}.c18{font-weight:700}.c21{height:0pt}.c10{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c3 doc-content"><h2 class="c11" id="h.1aeanq54twe0"><span class="c0">One Port to Rule Them All: Turn WebRTC media servers into a single Kubernetes service</span></h2><p class="c13 c10"><span class="c29"></span></p><p class="c13"><span class="c4">Scaling WebRTC media servers in a traditional self-hosted setup can be challenging. For media server providers, it involves complex network management, including handling firewall issues and protecting against malicious attacks on public-facing media servers. As the business grows, additional media servers need to be added, which requires new IP addresses. On the other hand, enterprises that want to use services from media server providers often have strict firewall policies that restrict the use of many ports, especially for UDP traffic. In certain industries, this level of exposure can be a dealbreaker.</span></p><p class="c13"><span>The cloud offers a promising solution by placing servers behind a single load balancer. However, </span><span class="c18">Kubernetes</span><span>&mdash;the most prominent platform&mdash;is not optimized for WebRTC traffic. Most WebRTC sessions use UDP as the transport protocol, but unlike TCP, UDP is connectionless by design. Moreover, m</span><span>edia traffic is usually long-lasting compared to the typical HTTP/TCP response requests for which Kubernetes was designed</span><span class="c4">. Hence routing in the transport layer is unfeasible with traditional load balancers used in Kubernetes.</span></p><p class="c13"><span class="c4">We want to use Kubernetes because it offers a solution for media servers to scale and deploy on a cloud platform operators aim to reduce the number of firewall exceptions enterprises need to allow to a single IP and port.</span></p><p class="c13"><span>This blog post&rsquo;ll explore the challenges of using Kubernetes for WebRTC media servers, explain how a Kubernetes media gateway can address these challenges, and walk you through our demo project,</span><span><a class="c16" href="https://www.google.com/url?q=http://www.webrtc-observer.org&amp;sa=D&amp;source=editors&amp;ust=1758022614909544&amp;usg=AOvVaw0AP6wBA9sYIPTzuyl8h2oS">&nbsp;</a></span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://www.webrtc-observer.org&amp;sa=D&amp;source=editors&amp;ust=1758022614909656&amp;usg=AOvVaw33pvvBo6Uw28qJphaojKFy">www.webrtc-observer.org</a></span><span>. </span><span>In this demo </span><span>project</span><span>, we&#39;ll show how to deploy a WebRTC service in Kubernetes with STUNner multiplexing WebRTC traffic into Kubernetes and use open-source libraries for monitoring WebRTC sessions.</span></p><p class="c13"><span>Let&rsquo;s dive in!</span></p><h2 class="c5" id="h.7jmdwgcodmh5"><span>The Challenge: Putting the WebRTC Media Servers into Kubernetes</span></h2><p class="c13"><span>One</span><span>&nbsp;of Kubernetes&#39; main selling points is its ability to securely host and scale workloads within a distinct, closed perimeter. Typical Kubernetes workloads, like web servers handling millions of HTTP requests, are shielded behind a single load balancer that routes stateful TCP requests to the appropriate server instances. However, this is not the case for </span><span>UDP-based</span><span class="c4">&nbsp;WebRTC traffic. The issue stems from the way Kubernetes handles networking, which heavily relies on NAT (Network Address Translation) to interconnect pods. This creates problems for WebRTC, as the connectionless nature of UDP makes it difficult to maintain stable sessions. If there are changes in the IP address or port&mdash;common when dealing with NAT&mdash;the media connections can break, disrupting communications.</span></p><p class="c13"><span>To get around networking issues, Kubernetes newbies often switch to node ports and host networking to make servers publicly accessible. However, </span><span class="c30"><a class="c16" href="https://www.google.com/url?q=https://medium.com/l7mp-technologies/open-source-turn-server-showdown-coturn-vs-stunner-da3a02a2fc9d&amp;sa=D&amp;source=editors&amp;ust=1758022614911119&amp;usg=AOvVaw18UJi--M02WXnCDM6VCd0Y">this approach is</a></span><span><a class="c16" href="https://www.google.com/url?q=https://medium.com/l7mp-technologies/open-source-turn-server-showdown-coturn-vs-stunner-da3a02a2fc9d&amp;sa=D&amp;source=editors&amp;ust=1758022614911199&amp;usg=AOvVaw1PXW2sIg1eKUm6m3sJN54B">&nbsp;both </a></span><span class="c30"><a class="c16" href="https://www.google.com/url?q=https://medium.com/l7mp-technologies/open-source-turn-server-showdown-coturn-vs-stunner-da3a02a2fc9d&amp;sa=D&amp;source=editors&amp;ust=1758022614911278&amp;usg=AOvVaw14I_kaEwdY5V-wZmHc84Gb">insecure</a></span><span>&nbsp;and impractical. First, exposing thousands of ports to the public just to allow access to internal services is off the table in many cases. Consider industries like banking or government, where protecting sensitive data and minimizing attack surfaces are critical requirements. Defending against DDoS attacks and spoofing across hundreds of open port ranges would be unmanageable in practice and is explicitly discouraged by regulations, which require to &ldquo;</span><span class="c30"><a class="c16" href="https://www.google.com/url?q=https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r5.pdf&amp;sa=D&amp;source=editors&amp;ust=1758022614911839&amp;usg=AOvVaw1mCR_jkGx8cTj99-JT21tE">limit the number of external network connections to the system</a></span><span class="c4">&rdquo;.</span></p><p class="c13"><span>Another drawback of sticking to the traditional manual setup is that it keeps the media server instances as unique &lsquo;snowflakes,&rsquo; requiring a hand-crafted collection of scripts and step-by-step guides for even the simplest tasks like scaling, upgrades, or failure recovery. Not taking advantage of the automation that Kubernetes offers also limits reaction times to dynamic load spikes or outages. So the question arises naturally: how can we solve WebRTC&rsquo;s NAT problem in Kubernetes to enable cloud-native deployment of media servers? TL;DR: </span><span class="c30"><a class="c16" href="https://www.google.com/url?q=https://medium.com/l7mp-technologies/use-of-turn-in-webrtc-revisited-it-may-be-more-useful-than-you-thought-856059fd27a3&amp;sa=D&amp;source=editors&amp;ust=1758022614912632&amp;usg=AOvVaw3AYefT9UlZpJDsZ3K118mm">STUNner the Kubernetes media gateway leverages the TURN functionality</a></span><span class="c4">! Now, let&rsquo;s dive into the details.</span></p><h2 class="c5" id="h.4ws0wcd0x86b"><span>Basics of STUNner the Kubernetes media gateway</span></h2><p class="c9 c19"><span>You&rsquo;re likely already familiar with the ICE (Interactive Connectivity Establishment) framework, which is designed to find a viable path between peers when direct connectivity is unavailable. ICE relies on STUN and TURN services to connect clients behind firewalls or NATs. For example, if UDP packets are blocked in corporate networks, a TURN server, acting as a UDP relay, can step in as a middleman between the clients, allowing them to exchange data.</span></p><p class="c25 c19 c10"><span class="c4"></span></p><p class="c9 c19"><span>Now, the idea behind STUNner is to repurpose the TURN service as an ingress media gateway for Kubernetes, providing NAT traversal for both clients and media servers. </span><span>Let&rsquo;s break down how this works with the help of Fig. 1</span><span class="c4">.</span></p><p class="c25 c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 492.00px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 492.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c14"><span class="c4">Fig. 1: Key components and steps required to connect a single client to a media server running behind STUNner. Note that media servers can vary, which may result in different signal flows.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span>The</span><span class="c4">&nbsp;left side gives an overview of the key components. Our WebRTC system runs in a Kubernetes cluster, which includes the Application Server and a fleet of Media Server pods. Clients can access the services through a single IP and port, exposed by a load balancer. The message flow diagram on the right guides us through the steps of the connection setup.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span>The first step for clients is to </span><span class="c18">register</span><span>&nbsp;with the Application Server, and in return, they receive the ICE configuration, which lists STUNner as the sole TURN server, along with the necessary TURN credentials (</span><span>Fig. 2</span><span>). But how does the Application Server know the public IP of the Load Balancer and the TURN credentials? This is where the STUNner Auth Service comes into play by keeping track of these variables and providing them </span><span>through</span><span>&nbsp;a REST API.</span></p><p class="c10 c35"><span class="c27 c7"></span></p><table class="c33"><tr class="c21"><td class="c12" colspan="1" rowspan="1"><p class="c9"><span class="c20 c23">{<br> &nbsp;&quot;id&quot;: </span><span class="c15">&quot;registerResponse&quot;</span><span class="c20 c23">,<br> &nbsp;&quot;response&quot;: </span><span class="c15">&quot;accepted&quot;</span><span class="c20 c23">,<br> &nbsp;&quot;iceConfiguration&quot;: {<br> &nbsp; &nbsp;&quot;iceServers&quot;: [<br> &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;&quot;urls&quot;: [</span><span class="c15">&quot;turn:192.0.2.1:3478?transport=udp&quot;</span><span class="c20 c23">],<br> &nbsp; &nbsp; &nbsp; &nbsp;&quot;username&quot;: </span><span class="c15">&quot;user-1&quot;</span><span class="c20 c23">,<br> &nbsp; &nbsp; &nbsp; &nbsp;&quot;credential&quot;: </span><span class="c15">&quot;pass-1&quot;</span><span class="c20 c23"><br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;],<br> &nbsp; &nbsp;&quot;iceTransportPolicy&quot;: </span><span class="c15">&quot;relay&quot;</span><span class="c20 c23"><br> &nbsp;}<br>}</span></p></td></tr></table><p class="c14"><span class="c7">Fig. 2: The ICE configuration returned by the Application Server. Note that transport can be TCP as well, and a single response can contain both settings.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span>When Client 1 wants to join a video conference, it notifies the Application Server with a </span><span class="c18">call</span><span class="c4">&nbsp;message that includes its SDP. The Application Server forwards this offer to a selected media server, let&rsquo;s say Media Server 1, and returns the generated SDP answer in the response message. This, of course, means the Application Server must track user sessions and media server instances to route incoming sessions to the least loaded media server. </span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span>At this point, Client 1 is aware of the media descriptors and the next hop needed to establish connectivity with Media Server 1, which is STUNner! The client sends a TURN </span><span class="c18">allocate request</span><span>, which STUNner acknowledges by providing the details of the relay connection. Note that this is a private IP address, as the internal leg of STUNner connects to the Kubernetes CNI. However, since the media server pods also reside in the cluster, thanks to Kubernetes networking principles (all pods can communicate with each other without NAT), the ICE connectivity check completes successfully, allowing media packets to traverse between Client 1 and Media Server 1!</span></p><p class="c1"><span class="c4"></span></p><p class="c1"><span class="c4"></span></p><h2 class="c5" id="h.iam99b1ei5vq"><span class="c0">WebRTC and Kubernetes in action</span></h2><p class="c1"><span class="c4"></span></p><p class="c19 c10 c25"><span class="c4"></span></p><p class="c25 c19 c10"><span class="c4"></span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 689.21px; height: 404.00px;"><img alt="" src="images/image2.png" style="width: 689.21px; height: 404.00px; margin-left: -4.10px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9 c19"><span>Fig. 3: Architecture of the </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=http://www.webrtc-observer.org&amp;sa=D&amp;source=editors&amp;ust=1758022614917544&amp;usg=AOvVaw0_Dfaej6IFnVtNyFUA6812">www.webrtc-observer.org</a></span><span>&nbsp;demo application in Kubernetes, highlighting the external and internal ports, protocols, and the sampling points associated with the measurements visualized in Grafana.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span>We developed </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=http://www.webrtc-observer.org&amp;sa=D&amp;source=editors&amp;ust=1758022614917900&amp;usg=AOvVaw2RInj24BMtTZBktN2g1Rc2">www.webrtc-observer.org</a></span><span>&nbsp;to showcase various use cases of the ObserveRTC open-source WebRTC monitoring toolkit. The demo platform runs on Kubernetes (deployed in Google Kubernetes Engine). It uses the STUNner media gateway to ingest the WebRTC traffic into Kubernetes seamlessly. The source code is available on </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://github.com/ObserveRTC/webrtc-observer.org&amp;sa=D&amp;source=editors&amp;ust=1758022614918389&amp;usg=AOvVaw3ynIa47bgl6-PPmDZf9CHf">GitHub</a></span><span class="c4">.</span></p><p class="c2 c10"><span class="c4"></span></p><table class="c8"><tr class="c21"><td class="c22" colspan="1" rowspan="1"><p class="c9"><span class="c20">apiVersion: </span><span class="c17">apps/v1</span><span class="c20"><br>kind: </span><span class="c17">Deployment</span><span class="c20"><br>metadata:<br> &nbsp;name: </span><span class="c17">mediaserver</span><span class="c20"><br> &nbsp;labels:<br> &nbsp; &nbsp;app: </span><span class="c17">mediaserver</span><span class="c20"><br>spec:<br> &nbsp;replicas: </span><span class="c24">2</span><span class="c20"><br> &nbsp;selector:<br> &nbsp; &nbsp;matchLabels:<br> &nbsp; &nbsp; &nbsp;app: </span><span class="c17">mediaserver</span><span class="c20"><br></span><span class="c32"># Rest of the Deployment script...</span><span class="c20"><br></span><span class="c18 c34">---</span><span class="c20"><br>apiVersion: </span><span class="c17">v1</span><span class="c20"><br>kind: </span><span class="c17">Service</span><span class="c20"><br>metadata:<br> &nbsp;name: </span><span class="c17">mediaserver-media</span><span class="c20"><br> &nbsp;labels:<br> &nbsp; &nbsp;app: </span><span class="c17">mediaserver</span><span class="c20"><br>spec:<br> &nbsp;type: </span><span class="c17">ClusterIP</span><span class="c20"><br> &nbsp;ports:<br> &nbsp;- port: </span><span class="c24">5000</span><span class="c20"><br> &nbsp; &nbsp;protocol: </span><span class="c17">UDP</span><span class="c20"><br> &nbsp; &nbsp;name: </span><span class="c17">rtc-1</span><span class="c20"><br> &nbsp;- port: </span><span class="c24">5001</span><span class="c20"><br> &nbsp; &nbsp;protocol: </span><span class="c17">UDP</span><span class="c20"><br> &nbsp; &nbsp;name: </span><span class="c17">rtc-2</span><span class="c20"><br> &nbsp;selector:<br> &nbsp; &nbsp;app: </span><span class="c17">mediaserver</span></p></td></tr></table><p class="c2"><span>Snippet 1. YAML script describing the media server in Kubernetes. The full script is </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://github.com/ObserveRTC/webrtc-observer.org/blob/main/charts/webrtc-observer-org/templates/mediaserver.yaml&amp;sa=D&amp;source=editors&amp;ust=1758022614920709&amp;usg=AOvVaw24JMZ6WCvLGQo7Z1NsauzB">here</a></span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span>The system combines the media and app server functionalities into a single microservice, deployed using a Kubernetes Deployment resource </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://github.com/ObserveRTC/webrtc-observer.org/blob/main/charts/webrtc-observer-org/templates/mediaserver.yaml&amp;sa=D&amp;source=editors&amp;ust=1758022614921184&amp;usg=AOvVaw0mDNMIXfsyIIoAs5xMOi7S">YAML</a></span><span>&nbsp;(Snippet 1.)</span><span>. The </span><span>deployment </span><span>defines the number of replicas, ensuring scalability. When the Media Server instances start, they automatically discover and share information through Redis using </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://github.com/balazskreith/hamok-ts&amp;sa=D&amp;source=editors&amp;ust=1758022614921595&amp;usg=AOvVaw01a9haMnj2DJAx1kTmvzFG">Hamok</a></span><span>. This enables media transports to dynamically establish connections between </span><span>different media server instances</span><span class="c4">&nbsp;when participants in a call are connected to separate instances. </span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span>The Media Server leverages </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://mediasoup.org/&amp;sa=D&amp;source=editors&amp;ust=1758022614922034&amp;usg=AOvVaw10WifYsqz-L5rphmIL5Jx1">mediasoup</a></span><span class="c4">&nbsp;to provide WebRTC SFU functionality. Mediasoup enables WebRTC peer connections via its WebRtcTransport object. Typically, each WebRtcTransport requires its own dedicated server port. However, by utilizing a WebRTCServer, multiple WebRtcTransports can share a single UDP/TCP port.</span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span class="c4">This setup centralizes network traffic handling, eliminating the need for each transport to listen on its own IP address and port. As a result, all network traffic for one CPU core can be multiplexed into a single port per instance. Utilizing this, the service allocates two CPU threads per instance and exposes UDP ports 5000 and 5001 within the Kubernetes cluster to handle RTC traffic on each media-server pod.</span></p><p class="c2 c10"><span class="c4"></span></p><table class="c8"><tr class="c21"><td class="c22" colspan="1" rowspan="1"><p class="c9"><span class="c6">apiVersion: gateway.networking.k8s.io/v1</span></p><p class="c9"><span class="c6">kind: Gateway</span></p><p class="c9"><span class="c6">metadata:</span></p><p class="c9"><span class="c6">&nbsp; name: udp-gateway</span></p><p class="c9"><span class="c6">&nbsp; namespace: default</span></p><p class="c9"><span class="c6">spec:</span></p><p class="c9"><span class="c6">&nbsp; addresses:</span></p><p class="c9"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- value: {{ .Values.publicIP }}</span></p><p class="c9"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: IPAddress</span></p><p class="c9"><span class="c6">&nbsp; gatewayClassName: stunner-gatewayclass</span></p><p class="c9"><span class="c6">&nbsp; listeners:</span></p><p class="c9"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: udp-listener</span></p><p class="c9"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port: 3478</span></p><p class="c9"><span class="c6">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protocol: TURN-UDP</span></p><p class="c9"><span class="c6">---</span></p><p class="c9"><span class="c6">apiVersion: stunner.l7mp.io/v1</span></p><p class="c9"><span class="c6">kind: UDPRoute</span></p><p class="c9"><span class="c6">metadata:</span></p><p class="c9"><span class="c6">&nbsp; name: mediaserver</span></p><p class="c9"><span class="c6">&nbsp; namespace: default</span></p><p class="c9"><span class="c6">spec:</span></p><p class="c9"><span class="c6">&nbsp; parentRefs:</span></p><p class="c9"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: udp-gateway</span></p><p class="c9"><span class="c6">&nbsp; rules:</span></p><p class="c9"><span class="c6">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- backendRefs:</span></p><p class="c9"><span class="c6">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: mediaserver-media</span></p><p class="c9"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;namespace: default</span></p></td></tr></table><p class="c2"><span>Snippet 2. YAML script describing key STUNner components. The full script is </span><span class="c26"><a class="c16" href="https://www.google.com/url?q=https://github.com/ObserveRTC/webrtc-observer.org/blob/main/charts/webrtc-observer-org/templates/stunner.yaml&amp;sa=D&amp;source=editors&amp;ust=1758022614925321&amp;usg=AOvVaw295CLw3Ztr3JKOT363tq1J">here</a></span><span class="c4">&nbsp;</span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span>The next step in the setup involves multiplexing all pod-exposed ports (UDP 5000 and 5001) into a single Kubernetes service entry point (</span><span class="c31">mediaserver-media</span><span>). This cluster-internal service is configured as a backend for STUNner (see UDPRoute configuration in Snippet 2). STUNner initiates a standard Kubernetes gateway (called </span><span class="c31">udp-gateway</span><span class="c4">) to connect this service to the outside world. The gateway is configured with a UDP listener that acts as a TURN server for the clients on the UDP port 3478 (Snippet 2). The full script creates all required resources in less than 50 lines of code.</span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span>When a client establishes a WebSocket connection, the service acts as a signaling server, facilitating RTC capabilities. During this process,</span><span>&nbsp;the media-server retrieves TURN credentials from the STUNner authentication service</span><span class="c4">&nbsp;and provides it to the client with the capabilities. The media server&#39;s provided IP and port correspond to the pod&#39;s internal Kubernetes cluster IP, requiring the client to connect via TURN. The TURN URI includes the public IP of STUNner, enabling the client to initiate ICE negotiation.</span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span class="c4">The ICE negotiation is conducted with STUNner, which acts as a relay. It forwards media traffic between the client and the appropriate pod assigned to handle the media. This setup efficiently manages NAT traversal and ensures seamless media traffic routing in a Kubernetes environment.</span></p><p class="c2 c10"><span class="c4"></span></p><p class="c2"><span>Once the PeerConnection is established and media flows correctly, the service becomes a fully scalable media provider behind Kubernetes. The standout feature of this setup is its simplicity and efficiency: </span><span class="c18">no matter how many media servers are added, all client media connections are managed through a single IP address and port.</span><span class="c4">&nbsp;This approach maximizes scalability and minimizes complexity.</span></p><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 221.33px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 221.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c14"><span class="c7">Fig. 4: The ICE candidates visualized in the web application: The app &amp; media servers on the right are running in Kubernetes. Clients access them via a single TURN/UDP port exposed by the STUNner media gateway. Dashed lines represent the signaling over HTTP/WS.</span></p><p class="c13"><span>Figure 4 shows a straightforward representation of this approach. On the right side of the figure, we see the two media server instances running in Kubernetes. The clients connecting to these media-server pods are on the left. The media connectivity between the two entities goes through a single IP address and port via STUNner. The dashed lines are &quot;virtual links&quot; showing which media server instance the client connects.</span></p><h2 class="c13 c28" id="h.m8fqawmcqo3g"><span>Extra latency</span></h2><p class="c13"><span>When</span><span>&nbsp;it comes to using STUNner, a metric of particular interest is the additional latency introduced by STUNner as it acts as a gateway for media servers. Quantifying this latency is crucial to understanding its impact on overall call quality and optimizing performance in real-world scenarios.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span class="c4">An educated guess is that adding an extra TURN processing to the media data plane is a luxury since it adds extra latency. We instrumented STUNner to measure packet processing times (see the red dots in Fig. 3) to make this extra cost quantifiable. We expose these metrics in an embedded Grafana dashboard under the &#39;Learn more about STUNner&#39; page.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span class="c4">This dashboard presents the averaged packet processing time. A gauge shows the average last minute, while the time series plot details the history. The dashboard also displays the throughput averaged for the last minute and the number of active connections.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 346.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 346.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c14"><span class="c7">Fig. 5: STUNner performance metrics: packet processing delays, throughput, and number of active connections. The dashboard is visible under &lsquo;Learn more about STUNner&rsquo; on the website.</span></p><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span class="c4">As Figure 5 shows, the packet processing delays are almost negligible. We see a slight increase when a new client connects. However, this spike disappears as the TURN signaling is over, and STUNner relays media traffic only.</span></p><p class="c1"><span class="c4"></span></p><h2 class="c5" id="h.6f84l3g7hg5p"><span class="c0">Conclusion</span></h2><p class="c1"><span class="c4"></span></p><p class="c9 c19"><span>It&#39;s time to wrap up our Kubernetes journey. In this blog post, we first learned about the challenges of deploying WebRTC applications to Kubernetes. We have seen how the STUNner media gateway exposes our WebRTC services with the help of the good old TURN and some Kubernetes Gateway magic. </span><span class="c18">STUNner uses a single IP and port to ingest</span><span class="c18">&nbsp;</span><span class="c18">all media traffic</span><span>&nbsp;and </span><span class="c18">secure our deployments</span><span>. So far, this is a fairy tale, but what about performance? We developed a mediasoup-based demo project to measure performance metrics. We use ObserveRTC and cloud-native monitoring tools to quantify the STUNner overhead. Our results show </span><span class="c18">the STUNner overhead is negligible</span><span>. Meanwhile, we can obtain</span><span class="c18">&nbsp;meaningful statistics with ObserveRTC</span><span class="c4">&nbsp;in Kubernetes, too.</span></p><p class="c1"><span class="c4"></span></p><p class="c1"><span class="c37"></span></p></body></html>